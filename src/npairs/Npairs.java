package npairs;

import npairs.shared.matlib.*;

import java.io.IOException;
import java.io.PrintStream;

import npairs.utils.CVA;
import npairs.utils.PCA;
import npairs.utils.PredictionStats;
import npairs.utils.Resampler;
import npairs.io.NiftiIO;
import npairs.io.NpairsIO;
import npairs.utils.ZScorePatternInfo;
import npairs.io.NpairsDataLoader;

import pls.shared.MLFuncs;

/***************************************************************************************
 * Main entry point for NPAIRS program.
 * @author Anita Oder
 * 
 **************************************************************************************/
public class Npairs  {
	
	boolean debug = false;
	
	 
	private NpairsSetupParams setupParams; // Contains all param info entered by user.
	
	private Resampler resampler;           // Contains split object resampling details
	
	private NpairsDataLoader dataLoader;   // Contains Npairs data, feat-selected data and inverse feature-
	                                       // selected data Matrices.
	
	/* Results: */
	
	private Analysis fullDataAnalysis = null; // contains results from full-data analysis, if run 
	
	private CVA fullDataCVA;          // contains CVA results from full-data analysis, if run
	
	private CVA splitDataCVA1;        // contains CVA results from first half split-data analysis, 
									  // if run (holds temp results from each split analysis as it's run)
	
	private CVA splitDataCVA2;	      // contains CVA results from second half split-data analysis, 
	                                  // if run (holds temp results from each split analysis as it's run)
	
	private PCA fullDataPCA;          // contains PCA results from full-data analysis, if run
	
	private PCA splitDataPCA1;        // contains PCA results from first half split-data analysis, 
									  // if run (holds temp results from each split analysis as it's run)
	
	private PCA splitDataPCA2;	      // contains PCA results from second half split-data analysis, 
    								  // if run (holds temp results from each split analysis as it's run)
	
	private Matrix split1CVAEvals;    // contains eigenvalues for each first split half (numSamples
	                                  // of them) and each CV dimension; dims = numSamples rows
    								  // X num CV dims cols
	
	private Matrix split2CVAEvals;    // contains eigenvalues for each second split half (numSamples
    								  // of them) and each CV dimension; dims = numSamples rows
	                                  // X num CV dims cols
	
	private double[] avgSplit1CVAEvals; // contains avg CV evals across first split half CVA results;
	                                    // length of array = num CV dims
	private double[] avgSplit2CVAEvals; // contains avg CV evals across second split half CVA results;
	                                    // length of array = num CV dims
	 
	private Matrix avgCVScoresTrain;   // contains avg cv scores across all training sets;
	                                   // dims = num input data vols X num cv dims
	
	private Matrix avgCVScoresTest;    // contains avg cv scores across all test sets, i.e.,
	                                   // avg of cv scores generated by projecting test data onto
	                                   // corresponding training cv eigenimages;
	                                   // dims = num input data vols X num cv dims
	
	private Matrix[] r2;               // contains r^2 values calculated for each split half
	                                   // between CV scores and data input into CV (e.g. PC scores
	                                   // representing data in PC space)
	
	private Matrix corrCoeffs;         // contains correlation coefficients for each split 
    								   // between eigenimages from each split half analysis; 
    								   // dims are: numSamples rows (see 'splits' above) by
    								   // num dims in eigenimage results for model  
       								   // to be summarized (e.g. CV dims)
									   // (ONLY EXISTS if split 2 models are generated, i.e.,
	                                   // if training and test sets are switched.)

	private Matrix noisePattStdDev;            // contains standard deviation of data from both split
                                       // halves projected onto 'noise' axis of scatterplot 
                                       // between split halves
                                       // dims are same as for corrCoeffs above
									   // (ONLY EXISTS if split 2 models are generated, i.e.,
    								   // if training and test sets are switched.)
	/* Prediction stats */
	
	// TODO: consider better storage strategy for prediction stats (ppAllClasses ordering of dims 
	//       inconsistent with rest of prediction variables; storing correctPred as array of double 
	//       Matrices is unwieldy)
	
	private Matrix[] ppTrueClass;       // for each test volume, contains posterior probabilities 
									   // (with and without priors)
	                                   // of belonging to true class 
	                                   // (1 Matrix for each split half)
	                                   // 1st row of each Matrix = probs with priors
	                                   // 2nd row "   "     "    = probs without priors
	
	private Matrix[] sqrdPredError;     // contains squared prediction error (1-ppTrueClass)^2
	                                   // (with and without priors)
    							       // for each test volume  
                                       // (1 Matrix for each split half)
                                       // 1st row of each Matrix = SPE with priors
                                       // 2nd row "   "     "    = SPE without priors
	
	private Matrix[] predClass;         // contains predicted class for each test volume
									   // (with and without priors)
									   // (1 Matrix for each split half)
									   // 1st row of each Matrix = probs with priors
									   // 2nd row "   "     "    = probs without priors
	
	private Matrix[] correctPred;       // contains labels for each test volume indicating 
	                                   // whether predicted class is true class: 
	                                   // 1.0 = true; 0.0 = false.
									   // (1 Matrix for each split half)
									   // 1st row of each Matrix = probs with priors
									   // 2nd row "   "     "    = probs without priors
	
	private Matrix[][] ppAllClasses;    // contains posterior probs (with and without priors)
	                                   // for each test volume of belonging to each class
	                                   // 	ppAllClasses[i][j] =  
	                                   // 	(no. test vols) X (no. classes) Matrix
	                                   // 	for j = 0 (priors) or 1 (no priors);
	                                   //   ith split half
/*	 Summary results:*/
	
	private Matrix avgSpatialPattern;  // contains spatial pattern average across all training
	                                  // datasets for analysis step that is to be 
									  // summarized (e.g. CVA results in PCA + CVA analysis, or 
									  // PCA results if only PCA run)
	                                  // No. of training sets: 2 * # splits in split-half X-validation;
	                                  //                           # input vols in bootstrap
	
	private Matrix avgZScorePattern;   // contains average rSPM(z) [normalized proj. of split 
	                                  // half patterns
		                              // onto 'signal axis'] across all splits for model  
	                                  // to be summarized
	                                  // (ONLY EXISTS if split 2 models are generated, i.e. if
	                                  // training and test sets are switched.)
	
	private Matrix avgNoisePattern;	          // contains average noise pattern [normalized proj. of
	                                  // split half patterns onto 'noise axis'] across all
	                                  // splits for model to be summarized
									  // (ONLY EXISTS if split 2 models are generated, i.e. if
                                      // training and test sets are switched.)
	
	// TODO: calculate and save Npairs.pattHistograms, Npairs.zScorePattHistograms,
	//       Npairs.summInfluence
	
//	private Matrix pattHistograms;  // contains histograms for spatial patterns generated
	                                // from each training set (only for analysis step that
	                                // is to be summarized)
	                                // ** will worry about details of generating this stat
	                                // later; implementation shown here will probably need
	                                // tweaking-- should be OK in terms of code structure, 
	                                // though **
	                                
//	private Matrix zScorePattHistograms;    // contains histograms for rSPM(z) patterns from each
	                                // training set (only for analysis step that is to be 
	                                // summarized)
	                                // ** will worry about details of generating this stat
	                                // later; implementation shown here will probably need
	                                // tweaking-- should be OK in terms of code structure, 
	                                // though **
	                                
//	private Matrix summInfluence;           // contains influence metrics for each Subject/Session
	                                // ** will worry about details of generating this stat
	                                // later ** (not implemented yet here)
	private boolean reshapedR2 = false; // set to true if r2 has been reshaped to final summary
	                                    // format (where there are nCVDims Matrices, each with
	                                    // dims nSplitAnalyses X no. data dims (e.g. PC dims) 
	                                    // input into CVA split analyses).
	private boolean computeR2 = true;  // always save r2 info (unless doing JavaQuadCVA)
	
	private static PrintStream output = System.out; // for directing all output statements 
	                                        // (to e.g. console or log file);
	                                        // initialized in NpairsjSetupParams.initLogFile()
	

	/***************************************************************************************
	 * This constructor takes name of file containing analysis parameter settings.
	 * @param dataLoader Contains data to be fed into NPAIRS analysis. Data has been preprocessed 
	 *                   - i.e., initial feature selection and MSR (mean scan removal for each 
	 *                   session) have been done.
	 * @param paramMatFileName Name of .mat file containing NPAIRS parameter settings
	 * @param matlibType Which Matrix library to use in analysis	
	 * @param eventRelAnalysis True if input data is in 'datamat' (event-related) format; false if 
	 * 							input data is in original scan/timepoint format
	 * @throws NpairsException
	 * @throws IOException 
	 **************************************************************************************/
	public Npairs(NpairsDataLoader dataLoader, String paramMatFileName, String matlibType, 
			boolean eventRelAnalysis) throws NpairsException, IOException {
		this(dataLoader, new NpairsSetupParams(paramMatFileName, false),
				matlibType);
	}
	
	/***************************************************************************************
	 * This constructor takes NpairsSetupParams object containing analysis parameter settings.
	 * @param dataLoader Contains data to be fed into NPAIRS analysis. Data has been preprocessed 
	 * 					- i.e., initial feature selection and MSR (mean scan removal for each 
	 * 					session) have been done.
	 * @param nsp NPAIRS parameter settings
	 * @param matlibType Which Matrix library to use in analysis	
	 * @param eventRelAnalysis True if input data is in 'datamat' (event-related) format; false if 
	 * 							input data is in original scan/timepoint format
	 * @throws NpairsException
	 * @throws IOException 
	 **************************************************************************************/
	public Npairs(NpairsDataLoader dataLoader, NpairsSetupParams nsp, String matlibType) 
		throws NpairsException, IOException {
		this.setupParams = nsp;
		this.dataLoader = dataLoader;
	//	this.computeR2 = nsp.saveLotsOfFiles;
		nsp.setUseQuadCVA(false); 
		if (nsp.useQuadCVA()) computeR2 = false; // not implemented for quad cva		

		// TODO: fix saveListfile to work for updated NpairsjSetupParams dataFileNames and maskFileNames variables
//		if (setupParams.saveLotsOfFiles && setupParams.cvaRun) {
//			if (!setupParams.dataIs4D) {
//				try {
//					// save listfile (for IDL NPAIRS) 
//					// (needed to view cv scores plot using J. Anderson's idl tool
//					// 'cva_plot_cvs.pro')
//					setupParams.saveListfile();
//				}
//				catch (IOException e) {
//					throw new NpairsjException("Error saving listfile");
//				}
//			}
//		}
		
		double sTime = System.currentTimeMillis();			
		runAnalysis();
		double tTime = (System.currentTimeMillis() - sTime) / 1000;
		int hr = (int)(tTime / 3600);
		int min = (int)((tTime / 60) - (hr * 60));
		double s = tTime - (hr * 3600) - (min * 60) ;
			output.print("Total time running NPAIRS analysis: " + hr + 
					" h " + min + " min ");
			output.printf("%.3f", s);
			output.println(" s");
	}

	private void runAnalysis() throws NpairsException, IOException {
		// Full Data Analysis:
		if (setupParams.runFullDataAnalysis()) {			
			output.println("Running full-data analysis...");
			double sTime = System.currentTimeMillis();				
			runFullDataAnalysis();	
			double tTime = (System.currentTimeMillis() - sTime) / 1000;
			output.println("Finished running full data analysis [" + tTime + " s]");					
		}

		// Split Analyses and Stats Generation:
		if (setupParams.resampleData()) {
//			 TODO: verify whether full-data reference analysis is really always
			// required when resampling data
			if (!setupParams.runFullDataAnalysis()) {
				throw new NpairsException("Must run full-data reference analysis " +
				"before resampling data");
			}
			
			boolean random = true;
			createAndSaveSplits(random);
//			saveSplitVolInfo();

			output.println("Running split analyses...");
			double sTime = System.currentTimeMillis();				
			runSplitAnalyses();				
			double tTime = (System.currentTimeMillis() - sTime) / 1000;
			output.println("Finished running split analyses [" + tTime + " s]");		

			saveSummarySplitResults();
		}
	}
	
	private void saveSummarySplitResults() throws IOException, NpairsException {
		// Always save true class post probs with priors in text file as 2D array.
		// If saveLotsOfFiles, save all summary prediction results in ASCII/Analyze format.
		output.println("Saving prediction stats...");
		savePredictionStats(setupParams.saveLotsOfFiles());
		
		// Always save reproducibility stats in a textfile, too.
		output.println("Saving reproducibility stats... ");
		saveCorrCoeffs("IDL");
		
		// And R2 output...
		output.println("Saving r2 values for each split analysis...");
		saveSummaryR2("IDL");
		
		if (setupParams.saveLotsOfFiles()) {			
			output.println("Saving average CV Scores (training and test)..." );
			saveAvgCVScores("IDL");
			output.println("Saving average spatial pattern... ");
			saveAvgSpatPattern("IDL");
			
//			if (computeR2) {
//				output.println("Saving r2 values for each split analysis...");
//				saveSummaryR2("IDL");
//			}
			
			if (setupParams.switchTrainAndTestSets()) {
				output.println("Saving rSPM{Z}... ");
				saveZScoreAvgPatt("IDL");
				output.println("Saving average noise pattern... ");
				saveNoiseAvgPatt("IDL");
				output.println("Saving noise pattern stats... ");
				saveNoiseStdDev("IDL");
			}
		}
	}
	
	/** Saves summary r2 file across all splits for each CV Dim, not the individual 
	 *  r2 files that can be saved for each split analysis using CVA.saveCVAResultsIDL 
	 *  by setting boolean saveR2 input arg to true
	 * @param format
	 */
	private void saveSummaryR2(String format) throws NpairsException {
		if (!reshapedR2) {
			throw new NpairsException("Must reshape R2 Matrix array into summary " +
					"format before saving.");
		}
		if (format.toUpperCase().equals("IDL")) {		
				int nCVDims = r2.length;
				for (int cv = 0; cv < nCVDims; ++cv) {
					String r2SplitsFile = setupParams.getResultsFilePrefix() + ".CVA.SUMM.CVDIM_" 
						+ cv + ".r2";
					r2[cv].printToFile(r2SplitsFile, format);
				}
		}
		else {
			throw new  IllegalArgumentException("Output format \'" + format + "\' not "
					+ "implemented.");
		}	
	}

	private void runFullDataAnalysis() throws NpairsException, IOException {
		if (setupParams.doInitFeatSelect()) {
			fullDataAnalysis = new Analysis(dataLoader.getFeatSelData(), setupParams);
		} 
		else fullDataAnalysis = new Analysis(dataLoader.getDataInOrigSpace(), setupParams);

		fullDataAnalysis.run();

		fullDataPCA = fullDataAnalysis.getPCA(); // null if pca not run	
		fullDataCVA = fullDataAnalysis.getCVA(); // null if cva not run

		if (setupParams.doInitFeatSelect()) {
			// rotate results back to original space from 
			// initial feature selection space
			if (setupParams.runPCA()) {			
				if (setupParams.pcEigimsToBigSpace()) {
					// TODO: replace cvaPCSetAll with generalized PC dims
					// (since if CVA not run, won't have cva PC set)	
					output.print("Transforming PCA back into orig. space... ");
					double sTime = System.currentTimeMillis();
					fullDataPCA = fullDataPCA.rotateEigimsToOrigSpace(setupParams.getCvaPCSetAll(),
							dataLoader.getOrigSpaceXformFactorMatrix(), dataLoader.getDataInOrigSpace());
					double tTime = (System.currentTimeMillis() - sTime) / 1000;
					output.println("[" + tTime + " s]");

				}
			}
			if (setupParams.runCVA()) {
				double sTime = System.currentTimeMillis();
				if (debug) {
					output.print("Transforming CVA back into orig. space... ");
				}
				fullDataCVA.rotateEigimsToOrigSpace(dataLoader.getOrigSpaceXformFactorMatrix(), dataLoader.getDataInOrigSpace());
				if (debug) {
					double tTime = (System.currentTimeMillis() - sTime) / 1000;
					output.println("[" + tTime + " s]");
				}
			}
		}
		saveFullDataResults();
	}
	

	private void saveFullDataResults() throws IOException, NpairsException {
		if (setupParams.saveFullDataAnalysis() && setupParams.saveLotsOfFiles()) {
			if (setupParams.runPCA()) {
//				if (debug) {
					output.println("Saving full-data PCA results..."); 
//				}
				String pcaSavePref = setupParams.getResultsFilePrefix();
				if (!setupParams.pcEigimsToBigSpace()) {
					pcaSavePref += ".InitFSpace";
				}
				NpairsIO.savePCAResultsIDL(pcaSavePref, null,
						false, 0, 0, fullDataPCA);						
			}
			
			if (setupParams.runCVA()) {
//				if (debug) {
					output.println("Saving full-data CVA results...");
//				}
				fullDataCVA.saveCVAResultsIDL(setupParams.getResultsFilePrefix(), false, 0, 0, true);
			}
		}
		
		if (setupParams.saveDataPostPCA()) {
			// save denoised (i.e. PCA dim-reduced) input data 
			// (in orig img space)
			output.print("Saving denoised (post-PCA) image data... ");
			double sTime = System.currentTimeMillis();
			if (!setupParams.pcEigimsToBigSpace()) {
				// still need to project eigims into big space
				// before saving denoised data
				fullDataPCA = fullDataPCA.rotateEigimsToOrigSpace(setupParams.getCvaPCSetAll(),
					dataLoader.getOrigSpaceXformFactorMatrix(), dataLoader.getDataInOrigSpace());
			}
			//fullDataPCA.saveDataPostPCA(setupParams, dataLoader);
			NpairsIO.saveDataPostPCA(fullDataPCA, setupParams, dataLoader, output);
			double tTime = (System.currentTimeMillis() - sTime)/1000;
			output.println("[" + tTime + " s]");
		}
	}

	/** Runs split analyses and accumulates summary split results */	
	private void runSplitAnalyses() throws NpairsException, IOException {
		
		int numSamples = resampler.getNumSamples();
//		int numSamples = splits[0].length; // numSamples == min(setupParams.numSplits, max num splits)
		output.println("No. splits: " + numSamples);
		
		int totalNumSplitAnalyses = numSamples;
		if (setupParams.switchTrainAndTestSets()) {
			totalNumSplitAnalyses = 2 * numSamples;
		}
		
		initPredStats(totalNumSplitAnalyses);
		if (computeR2) {
			initR2Results(totalNumSplitAnalyses);  
		}

		if (setupParams.runCVA()) {
			initCVASplitResults(numSamples);
		}

		int[] vCountTr = new int[setupParams.getNumVols()]; 	// each element incremented whenever corresp.
														// vol (row of input data) incl. in sample 
        												// training data
		int[] vCountTe = new int[setupParams.getNumVols()]; 	// each element incremented whenever corresp.
        												// vol incl. in sample test data
	
		int numAnalyses = 0;
		for (int splitNum = 0; splitNum < numSamples; ++splitNum) {

			Analysis firstPartAnalysis;
			Analysis secondPartAnalysis = null;

			int[] split1DataVols = resampler.getSample(0, splitNum);
			int[] split2DataVols = resampler.getSample(1, splitNum);

			if (setupParams.doInitFeatSelect()) {
				firstPartAnalysis = 
					new Analysis(dataLoader.getFeatSelData(), setupParams, 
							split1DataVols, true, fullDataAnalysis);
				if (setupParams.switchTrainAndTestSets()) {
					secondPartAnalysis = 
						new Analysis(dataLoader.getFeatSelData(), setupParams, 
								split2DataVols, false, fullDataAnalysis);
				}
			}
			else {
				firstPartAnalysis = 
					new Analysis(dataLoader.getDataInOrigSpace(), setupParams, 
							split1DataVols, true, fullDataAnalysis);
				if (setupParams.switchTrainAndTestSets()) {
					secondPartAnalysis =
						new Analysis(dataLoader.getDataInOrigSpace(), setupParams, 
								split2DataVols, false, fullDataAnalysis);
				}
			}

			output.println("Split # 1/" 
					+ splitNum + ":");
			double sTime = System.currentTimeMillis();
			// split analysis CVA is matched to reference analysis 
			// within Analysis.run()
			firstPartAnalysis.run();
			double tTime = (System.currentTimeMillis() - sTime) / 1000;
			output.println("Done split. [" + tTime + " s]");
			++numAnalyses;

			if (setupParams.switchTrainAndTestSets()) {
				output.println("Split # 2/" 
						+ splitNum + ":");
				sTime = System.currentTimeMillis();
				secondPartAnalysis.run();
				tTime = (System.currentTimeMillis() - sTime) / 1000;
				output.println("Done split. [" + tTime + " s]");
				++numAnalyses;
			}
			
			if (setupParams.runPCA()) {
				splitDataPCA1 = firstPartAnalysis.getPCA(); 
				if (setupParams.switchTrainAndTestSets()) {
					splitDataPCA2 = secondPartAnalysis.getPCA();
				}
			}
			
			splitDataCVA1 = firstPartAnalysis.getCVA();  // null if cva not run
			splitDataCVA2 = secondPartAnalysis.getCVA(); // null if cva not run or training and 
														 // test data not switched
			
			// Add r2 stats Matrix for current split half to r2 Matrix array.
			if (computeR2) {
				addCurrR2(splitNum);
			}

			Matrix split1CVSTrain = null;
			Matrix split1CVSTest = null;
			Matrix split2CVSTrain = null;
			Matrix split2CVSTest = null;
			if (setupParams.runCVA()) {
				//  Incorporate current split into summary CV-Training and CV-Test Scores				
				split1CVAEvals.setRow(splitNum, splitDataCVA1.getEvals());

				// Split1CVSTrain = 0 for vols not incl. in current split data
				split1CVSTrain = getTrainCVScores(splitDataCVA1, split1DataVols);
				
				for (int vol : split1DataVols) {
					vCountTr[vol] += 1;
				}

				avgCVScoresTrain = avgCVScoresTrain.plus(split1CVSTrain);

				// Project curr split test (split2) data onto curr split train (split1) 
				// CV eigenimages to get curr test CV scores. 

				// Split2CVSMatrix contains zeros in rows corresp. to vols not
				// incl. in curr test data 
				split2CVSTest = getTestCVScores(splitDataCVA1, split2DataVols);
						
				for (int vol : split2DataVols) {
					vCountTe[vol] += 1;
				}				
				avgCVScoresTest = avgCVScoresTest.plus(split2CVSTest);

				if (setupParams.switchTrainAndTestSets()) {
					split2CVAEvals.setRow(splitNum, splitDataCVA2.getEvals());

					// Split2CVSTrain = 0 for vols not incl. in current split data
					split2CVSTrain = getTrainCVScores(splitDataCVA2, split2DataVols);

					for (int vol : split2DataVols) {
						vCountTr[vol] += 1;
					}

					avgCVScoresTrain = avgCVScoresTrain.plus(split2CVSTrain);
					// Project curr split test (split1) data onto curr split train (split2) 
					// CV eigenimages to get curr test CV scores. 

					// Split2CVSMatrix contains zeros in rows corresp. to vols not
					// incl. in curr test data 
					split1CVSTest = getTestCVScores(splitDataCVA2, split1DataVols);
					
					for (int vol : split1DataVols) {
						vCountTe[vol] += 1;
					}				
					avgCVScoresTest = avgCVScoresTest.plus(split1CVSTest);
				}
			}
			
			
			// Calculate prediction metrics. 
			// Prediction metrics can be calculated whenever there is a test 
			// set (or equivalently in NPAIRS, whenever resampling is done)
			computePredStats(numAnalyses, split1DataVols, split2DataVols, 
					split1CVSTrain, split1CVSTest, split2CVSTrain, split2CVSTest);

			// Transform eigenimages back into original image space
			if (setupParams.doInitFeatSelect()) {
				if (setupParams.runCVA()) {
					if (debug) {
						sTime = System.currentTimeMillis();
						output.print("Transforming split 1 CVA back into orig. space... ");
					}
					splitDataCVA1.rotateEigimsToOrigSpace(dataLoader.getOrigSpaceXformFactorMatrix(), 
							dataLoader.getDataInOrigSpace());
					if (debug) {
						tTime = (System.currentTimeMillis() - sTime) / 1000;
						output.println("[" + tTime + " s]");
					}
				}

				if (setupParams.runPCA()) {
					if (setupParams.pcEigimsToBigSpace() && setupParams.saveSplitDataResults()) {
						// Project back into original data voxel space (large and time-consuming);
						// default is to stay in initial feature (e.g. svd) eigenimage space rather
						// than voxel space
						if (debug) {
							sTime = System.currentTimeMillis();
							output.print("Transforming split 1 PCA back into orig. space... ");
						}
						splitDataPCA1 = splitDataPCA1.rotateEigimsToOrigSpace(setupParams.getCvaPCSet1(), 
								dataLoader.getOrigSpaceXformFactorMatrix(), dataLoader.getDataInOrigSpace());
						if (debug) {
							tTime = (System.currentTimeMillis() - sTime) / 1000;
							output.println("[" + tTime + " s]");
						}
					}
				}

				if (setupParams.switchTrainAndTestSets()) {
					if (setupParams.runCVA()) {
						if (debug) {
							sTime = System.currentTimeMillis();
							output.print("Transforming split 2 CVA back into orig. space... ");
						}
						splitDataCVA2.rotateEigimsToOrigSpace(dataLoader.getOrigSpaceXformFactorMatrix(), 
								dataLoader.getDataInOrigSpace());
						if (debug) {
							tTime = (System.currentTimeMillis() - sTime) / 1000;
							output.println("[" + tTime + " s]");
						}
					}

					if (setupParams.runPCA()) {
						if (setupParams.pcEigimsToBigSpace() && setupParams.saveSplitDataResults()) {
							if (debug) {
								sTime = System.currentTimeMillis();
								output.print("Transforming split 2 PCA back into orig. space... ");
							}
							splitDataPCA2 = splitDataPCA2.rotateEigimsToOrigSpace(setupParams.getCvaPCSet2(), 
									dataLoader.getOrigSpaceXformFactorMatrix(), dataLoader.getDataInOrigSpace());
							if (debug) {
								tTime = (System.currentTimeMillis() - sTime) / 1000;
								output.print("[" + tTime + " s]");
							}
						}
					}
				}
			}

			//	Save split results in ASCII format:
			if (setupParams.saveSplitDataResults()) {
				sTime = System.currentTimeMillis();
				output.print("Saving split results...");
				if (setupParams.runPCA()) {
					if (debug) {
						output.println("Saving 1st split half PCA results... ");
					}
					savePCASplitResults(splitNum, 1);
				}

				if (setupParams.runCVA()) {
					if (debug) {
						output.println("Saving 1st split half CVA results ");
					}
					splitDataCVA1.saveCVAResultsIDL(setupParams.getResultsFilePrefix(), 
							true, splitNum, 1, false);
				}

				if (setupParams.switchTrainAndTestSets()) {
					if (setupParams.runPCA()) {
						if (debug) {
							output.println("Saving 2nd split half PCA results... ");
						}
						savePCASplitResults(splitNum, 2);
					}

					if (setupParams.runCVA()) {
						if (debug) {
							output.println("Saving 2nd split half CVA results ");
						}
						splitDataCVA2.saveCVAResultsIDL(setupParams.getResultsFilePrefix(), 
								true, splitNum, 2, false);
					}
				}
				tTime = (System.currentTimeMillis() - sTime) / 1000;
				output.println("[" + tTime + " s]");
			}

			// Calculate various spatial patterns and reproducibility stats.
			// 

			if (setupParams.switchTrainAndTestSets()) {
				if (debug) {
					sTime = System.currentTimeMillis();
					output.print("Calculating Reproducibility stats... ");
				}
				ZScorePatternInfo zScorePattInfo = new ZScorePatternInfo(splitDataCVA1.getEigimsBig(), 
						splitDataCVA2.getEigimsBig());
				if (debug) {
					tTime = (System.currentTimeMillis() - sTime) / 1000;
					output.println("[" + tTime + " s]");
				}
				
				// Incorporate current split data analysis pattern results into 
				// cumulative average results.
				// TODO: clean up assumptions: currently, avg results only 
				// initialized and accumulated if setupParams.switchTrainAndTestSets == true,
				// and cva is assumed to have been run; but avgSpatialPattern should exist 
				// even if train and test sets are not switched.
				if (splitNum == 0) {
					avgSpatialPattern = splitDataCVA1.getEigimsBig();
					avgSpatialPattern = avgSpatialPattern.plus(splitDataCVA2.getEigimsBig());
					avgZScorePattern = zScorePattInfo.getSignalPattern();
					avgNoisePattern = zScorePattInfo.getNoisePattern();

					// must initialize noisePattStdDev and corrCoeffs 
					// because each col added one at a time
					noisePattStdDev = new MatrixImpl(numSamples, 
							avgNoisePattern.numCols()).getMatrix();
					// reproducibility = corrCoeffs (i.e., correlation coefficients 
					// between spatial patterns from pair of split half analyses)
					corrCoeffs =  new MatrixImpl(numSamples, 
							avgNoisePattern.numCols()).getMatrix();
				}
				else {
					avgSpatialPattern = avgSpatialPattern.plus(
							splitDataCVA1.getEigimsBig());
					avgSpatialPattern = avgSpatialPattern.plus(
							splitDataCVA2.getEigimsBig());
					avgZScorePattern = avgZScorePattern.plus(
							zScorePattInfo.getSignalPattern());
					avgNoisePattern = avgNoisePattern.plus(
							zScorePattInfo.getNoisePattern());
				}
				// Record stats for current split
				noisePattStdDev.setRow(splitNum, zScorePattInfo.getNoiseStdDev());
				corrCoeffs.setRow(splitNum, zScorePattInfo.getCorrCoeffs());

				// TODO: lift the following if statement out of splitNum for loop
				if (splitNum == numSamples - 1) {
					avgSpatialPattern = avgSpatialPattern.mult(1.0 / (double)(numSamples * 2));			
					avgZScorePattern = avgZScorePattern.mult(1.0 / (double)numSamples);
					avgNoisePattern = avgNoisePattern.mult(1.0 / (double)numSamples);					
				} 		
			} // end if switch train/test 
			
		} // end for loop through splits
		
		
		// Finish calculating avg cv scores and evals:
		// divide avgCVScoresTrain/Test rows by corresponding vCounts.  
		// If vCount = 0, then corresponding row in avgCVScoresTrain/Test 
		// will be all zeros.
		for (int r = 0; r < setupParams.getNumVols(); ++r) {
			if (vCountTr[r] > 0) {
				double[] avgCVSTrCurrRow = 
					MLFuncs.divide(avgCVScoresTrain.getRowQuick(r), (double)vCountTr[r]);
				avgCVScoresTrain.setRowQuick(r, avgCVSTrCurrRow);
			}
			if (vCountTe[r] > 0) {
				double[] avgCVSTestCurrRow = 
					MLFuncs.divide(avgCVScoresTest.getRowQuick(r), (double)vCountTe[r]);
				avgCVScoresTest.setRowQuick(r, avgCVSTestCurrRow);
			}
		}

		avgSplit1CVAEvals = split1CVAEvals.colMeans();
		if (setupParams.switchTrainAndTestSets()) {
			avgSplit2CVAEvals = split2CVAEvals.colMeans();
		}		

		// Reshape r2 data.  Currently have a Matrix (nPCDims X nCVDims) for 
		// each split analysis; want a Matrix (nSplitAnalyses X nPCDims) for 
		// each CV Dim.
		if (computeR2) {
			r2 = reshapeR2();
		}
		// Pad prediction stats with -1's so all Matrices have maxNTestVols columns
		padPredStats(totalNumSplitAnalyses);	

	}
	
	/** Rearranges r2 data from an array of (numSplitAnalyses) Matrices with
	 *  dims (nPCDims rows X nCVDims cols) to an array of (nCVDims) Matrices 
	 *  with dims (nSplitAnalyses rows X nPCDims cols).
	 * @return rearranged array of r2 Matrices
	 */
	private Matrix[] reshapeR2() {
		int nAnalyses = r2.length;
		int nPCDims = r2[0].numRows();
		int nCVDims = r2[0].numCols();
		Matrix[] r2PerCVDim = new Matrix[nCVDims];
		for (int cv = 0; cv < nCVDims; ++cv) {
			r2PerCVDim[cv] = new MatrixImpl(nAnalyses, nPCDims).getMatrix();
			for (int i = 0; i < nAnalyses; ++i) {
				r2PerCVDim[cv].setRow(i, r2[i].getColumn(cv));
			}
		}
		reshapedR2 = true;
		return r2PerCVDim;
	}

	/** Adds current split r2 stats to r2 Matrix 
	 * @param splitNum - (0-relative) number of current data split
	 * 
	 */
	private void addCurrR2(int splitNum) {
		int analysisNum = splitNum;
		if (setupParams.switchTrainAndTestSets()) {
			analysisNum *= 2;
		}
		if (setupParams.runCVA()) {
			r2[analysisNum] = splitDataCVA1.getR2();
			if (setupParams.switchTrainAndTestSets()) {
				r2[analysisNum + 1] = splitDataCVA2.getR2();
			}	
		}	
	}

	private void initR2Results(int totalNumSplitAnalyses) {
		r2 = new Matrix[totalNumSplitAnalyses];
	}

	private void initCVASplitResults(int numSamples) {
		// TODO: if split1,split2 have diff. number of pcs, the following
		// code will have to change
		int nCVDimsSplit1 = setupParams.getCvaPCSet1().length;
		int nCVDims = Math.min(fullDataCVA.getNumCVDims(), nCVDimsSplit1);
		split1CVAEvals = new MatrixImpl(numSamples, nCVDims).getMatrix();
		avgSplit1CVAEvals = new double[nCVDims];
		avgCVScoresTrain = new MatrixImpl(setupParams.getNumVols(), nCVDims).getMatrix();
		avgCVScoresTest = new MatrixImpl(setupParams.getNumVols(), nCVDims).getMatrix();

		if (setupParams.switchTrainAndTestSets()) {

			split2CVAEvals = new MatrixImpl(numSamples, nCVDims).getMatrix();
			avgSplit2CVAEvals = new double[nCVDims];
		}		
	}

	private void initPredStats(int totalNoSplitAnalyses) {
		ppTrueClass = new Matrix[totalNoSplitAnalyses];
		sqrdPredError = new Matrix[totalNoSplitAnalyses];
		predClass = new Matrix[totalNoSplitAnalyses];
		correctPred = new Matrix[totalNoSplitAnalyses];
		ppAllClasses = new Matrix[totalNoSplitAnalyses][2];
	}

	/** Determine samples for each split and save textfile containing sample info
	 *  in results directory.
	  * @param random
	  * 	If true, create uniformly random split samples (unless
	  *     no. of samples to be created is >= 90% of total
	  *     possible no. of samples; in this case, samples
	  *     are created deterministically even if 'random' is
	  *     set to 'true').
	  *     If false, create split samples deterministically.
	  * @see Resampler
	  */
	private void createAndSaveSplits(boolean random) throws NpairsException {

		if (setupParams.getSplitsInfoFilename() == "") {
			// no splits file specified so create new samples
			double sTime = System.currentTimeMillis();
			resampler = new Resampler(setupParams.getSplitObjLabels(), 
					setupParams.getGroupLabels(), setupParams.getNumSplitObjInSplits(), 
					setupParams.getNumSplits());

			// 'splits' is array with dims [2][numSamples][] where 
			// numSamples == min(numSplits, max poss splits)
			
			resampler.generateSplits(random);
			if (debug) {
				double tTime = (System.currentTimeMillis() - sTime) / 1000;
				output.println("Total time creating splits: " + tTime + " s");
			}
		} 
		else { // load samples from file specified in setup parameters
			try {
				resampler = new Resampler(setupParams.getSplitsInfoFilename());
			}
			catch (IOException ioe1) {
				throw new NpairsException("Unable to load split volume sample info from file: " 
					+ setupParams.getSplitsInfoFilename());
			}
		}
		try {
			// save samples info in results directory
			resampler.saveSplitVolInfo(setupParams.getResultsFilePrefix());
		}
		catch (IOException ioe) {
			throw new NpairsException("Unable to save sampled split volume info.");
		}
	}

	private void padPredStats(int totalNumAnalyses) {
		int maxNTestVols = 0;
		for (int i = 0; i < totalNumAnalyses; ++i) {
			maxNTestVols = Math.max(maxNTestVols,ppTrueClass[i].numCols());
		}

		for (int j = 0; j < totalNumAnalyses; ++j) {
			if (ppTrueClass[j].numCols() < maxNTestVols) {
				Matrix tmpPP = new MatrixImpl(2, maxNTestVols).getMatrix();
				tmpPP.set(-1);
				tmpPP.setSubMatrix(ppTrueClass[j], 0, 0);
				ppTrueClass[j] = tmpPP;

				Matrix tmpSPE = new MatrixImpl(2, maxNTestVols).getMatrix();
				tmpSPE.set(-1);
				tmpSPE.setSubMatrix(sqrdPredError[j], 0, 0);
				sqrdPredError[j] = tmpSPE;

				Matrix tmpPredCls = new MatrixImpl(2, maxNTestVols).getMatrix();
				tmpPredCls.set(-1);
				tmpPredCls.setSubMatrix(predClass[j], 0, 0);
				predClass[j] = tmpPredCls;

				Matrix tmpCorrPred = new MatrixImpl(2, maxNTestVols).getMatrix();
				tmpCorrPred.set(-1);
				tmpCorrPred.setSubMatrix(correctPred[j], 0, 0);
				correctPred[j] = tmpCorrPred;

				int nModelDims = ppAllClasses[0][0].numCols();
				Matrix tmpPPAll = new MatrixImpl(maxNTestVols, nModelDims).getMatrix();
				tmpPPAll.set(-1);
				tmpPPAll.setSubMatrix(ppAllClasses[j][0], 0, 0);
				ppAllClasses[j][0] = tmpPPAll;
				Matrix tmpPPAllNoP = new MatrixImpl(maxNTestVols, nModelDims).getMatrix();
				tmpPPAllNoP.set(-1);
				tmpPPAllNoP.setSubMatrix(ppAllClasses[j][1], 0, 0);
				ppAllClasses[j][1] = tmpPPAllNoP;			
			}	
		}
	}

	private void computePredStats(int numAnalyses, 
								int[] split1DataVols, 
								int[] split2DataVols, 
								Matrix split1CVSTrain, 
								Matrix split1CVSTest, 
								Matrix split2CVSTrain, 
								Matrix split2CVSTest) throws NpairsException {
		double sTime = 0;
		double tTime = 0;
		if (debug) {
			output.print("Calculating Prediction Stats "
					+ "for 1st split half... ");
			sTime = System.currentTimeMillis();
		}
		PredictionStats predStats1 = new PredictionStats(split1CVSTrain, split2CVSTest,
				split1DataVols, split2DataVols, setupParams.getClassLabels());
		if (debug) {
			tTime = (System.currentTimeMillis() - sTime) / 1000;
			output.println("[" + tTime + "]");
		}

		// add to cumulative prediction stats
		int currAnalysis = numAnalyses;
		if (setupParams.switchTrainAndTestSets()) {
			currAnalysis--;  // numAnalyses was incremented twice but curr 
			// analysis is for first train set
		}
		ppTrueClass[currAnalysis - 1] = new MatrixImpl(predStats1.
				getPPTrueClass()).getMatrix();
		sqrdPredError[currAnalysis - 1] = new MatrixImpl(predStats1.
				getSqrdPredError()).getMatrix();
		predClass[currAnalysis - 1] = new MatrixImpl(predStats1.
				getPredClass()).getMatrix();
		correctPred[currAnalysis - 1] = new MatrixImpl(predStats1.
				getCorrectPred()).getMatrix();
		ppAllClasses[currAnalysis - 1][0] = new MatrixImpl(predStats1.
				getPPAllClasses(0)).getMatrix();
		ppAllClasses[currAnalysis - 1][1] = new MatrixImpl(predStats1.
				getPPAllClasses(1)).getMatrix();

		PredictionStats predStats2 = null;
		if (setupParams.switchTrainAndTestSets()) {
			currAnalysis++; // was decremented for first train set
			if (debug) {
				output.print("Calculating Prediction Stats "
						+ "for 2nd split half... ");
				sTime = System.currentTimeMillis();
			}
			predStats2 = new PredictionStats(split2CVSTrain, split1CVSTest,
					split2DataVols, split1DataVols, setupParams.getClassLabels());			
			if (debug) {
				tTime = (System.currentTimeMillis() - sTime) / 1000;
				output.println("[" + tTime + "]");
			}

			ppTrueClass[currAnalysis - 1] = new MatrixImpl(predStats2.
					getPPTrueClass()).getMatrix();
			sqrdPredError[currAnalysis - 1] = new MatrixImpl(predStats2.
					getSqrdPredError()).getMatrix();
			predClass[currAnalysis - 1] = new MatrixImpl(predStats2.
					getPredClass()).getMatrix();
			correctPred[currAnalysis - 1] = new MatrixImpl(predStats2.
					getCorrectPred()).getMatrix();
			ppAllClasses[currAnalysis - 1][0] = new MatrixImpl(predStats2.
					getPPAllClasses(0)).getMatrix();
			ppAllClasses[currAnalysis - 1][1] = new MatrixImpl(predStats2.
					getPPAllClasses(1)).getMatrix();
		}
	}
	

	
	
	private void savePredictionStats(boolean saveLotsOfFiles) throws IOException {
	
		// Matrix[totalNumAnalyses] ppTrueClass
		//         "                sqrdPredError
		//         "                predClass                                            
        //         "                correctPred
	    // Matrix[totalNumAnalyses][2] ppAllClasses
		//  - each Matrix is 2 X num test vols except
		//    for ppAllClasses Matrices, which are
		//    num test vols X num classes
		
		int nAnalyses = ppTrueClass.length;
		int maxNTestVols = 0;  // not all test sets have same number of vols
		for (int i = 0; i < nAnalyses; ++i) {
			maxNTestVols = Math.max(maxNTestVols, ppTrueClass[i].numCols());
		}
		// always save true class post probs with priors for all split halves and test vols
		// in text file as 2D array, even if not saving lots of files
		Matrix ppTrueClsPriors = new MatrixImpl(nAnalyses, maxNTestVols).getMatrix();
		for (int i = 0; i < nAnalyses; ++i) {
			ppTrueClsPriors.setRow(i, ppTrueClass[i].getRow(0));
		}
		String modelType = "";
		if (setupParams.runCVA()) {
			modelType = "CVA";
		}
		String ppTruePriorsFilename = setupParams.getResultsFilePrefix() + "." + modelType + 
			".SUMM.PP.ppTruePriors";
		ppTrueClsPriors.printToFile(ppTruePriorsFilename, "IDL");
		
		if (saveLotsOfFiles) {	// save all the prediction stats, not just the true class post probs

			int nModelDims = ppAllClasses[0][0].numCols();
			double[][][] ppTrueCls3D = new double[nAnalyses][2][maxNTestVols];
			double[][][] sqrdPredErr3D = new double[nAnalyses][2][maxNTestVols];
			double[][][] predCls3D = new double[nAnalyses][2][maxNTestVols];
			double[][][] corrPred3D = new double[nAnalyses][2][maxNTestVols];
			double[][][] ppAllClsPriors3D = new double[nAnalyses][maxNTestVols][nModelDims]; 
			double[][][] ppAllClsNoPriors3D = new double[nAnalyses][maxNTestVols][nModelDims]; 

			for (int i = 0; i < nAnalyses; ++i) {
				ppTrueCls3D[i] = ppTrueClass[i].toArray();
				sqrdPredErr3D[i] = sqrdPredError[i].toArray();
				predCls3D[i] = predClass[i].toArray();
				corrPred3D[i] = correctPred[i].toArray();
				ppAllClsPriors3D[i] = ppAllClasses[i][0].toArray();
				ppAllClsNoPriors3D[i] = ppAllClasses[i][1].toArray();
			}

			// save in .img/hdr 3D volume format 
			String ppTrueFilename = setupParams.getResultsFilePrefix() + "." + modelType + ".SUMM.PP.pp";
			String speFilename = setupParams.getResultsFilePrefix() + "." + modelType + ".SUMM.PP.spe";
			String predClsFilename = setupParams.getResultsFilePrefix() + "." + modelType + ".SUMM.PP.predCls";
			String corrPFilename = setupParams.getResultsFilePrefix() + "." + modelType + ".SUMM.PP.pred";
			String ppAllPriorsFilename = setupParams.getResultsFilePrefix() + "." + modelType + ".SUMM.PP.ppAllPriors";
			String ppAllNoPriorsFilename = setupParams.getResultsFilePrefix() + "." + modelType + ".SUMM.PP.ppAllNoPriors";

			// TODO: consider xyz ordering in these volumes (although they're not images, we still
			// need to understand how the data is ordered in the file)
			int datatype = 16; // 32-bit float
			NiftiIO.writeVol(ppTrueCls3D, datatype, ppTrueFilename);
			NiftiIO.writeVol(sqrdPredErr3D, datatype, speFilename);
			NiftiIO.writeVol(predCls3D, datatype, predClsFilename);
			NiftiIO.writeVol(corrPred3D, datatype, corrPFilename);
			NiftiIO.writeVol(ppAllClsPriors3D, datatype, ppAllPriorsFilename);
			NiftiIO.writeVol(ppAllClsNoPriors3D, datatype, ppAllNoPriorsFilename);

		}		
	}


	
	//**************************************************************************************
	// Private helper methods:
	//**************************************************************************************	
	
	/** Returns new Matrix containing test CV scores, i.e., cvaTest data
	 *  projected onto cvaTrain CVA eigenimages, for vols in test data set.
	 *  Vols not incl. in test data set have cv scores set to zero in 
	 *  returned Matrix.
	 *  Dim CVA eigenimages -  numDataCols (nVox, nFeatSelDims or nPCDimsForCVA) X nCVDims
	 *  Dim testData - numTestDataVols X numDataCols
	 *  
	 *   @param cvaTrain - cva of training data 
	 *   @param testDataVols - indices of vols (rows) of test data in full data set 
	 */ 
	private Matrix getTestCVScores(CVA cvaTrain, int[] testDataVols) {
		Matrix testData = null;	

		if (setupParams.doInitFeatSelect()) {
			testData = dataLoader.getFeatSelData().subMatrixRows(testDataVols);
		}
		else {
			testData = dataLoader.getDataInOrigSpace().subMatrixRows(testDataVols);
		}
		testData = testData.meanCentreColumns();
		
		Matrix cvsTest = cvaTrain.calcTestCVScores(testData);
		Matrix cvsTestPadded = cvsTest.zeroPadRows(setupParams.getNumVols(), testDataVols);
		return cvsTestPadded;
	}
	
	
	/** Returns new Matrix containing training CV scores.
	 *  Vols not incl. in training data set have cv scores set to zero in 
	 *  returned Matrix.
	 *  Dim CVA eigenimages -  <i>numDataCols</i> (<i>nVox</i> or <i>nFeatSelDims</i>) 
	 *  							X <i>nCVDims</i>
	 *  Dim trainingData - <i>numTrainDataVols</i> X <i>numDataCols</i>
	 *  
	 *   @param cvaTrain - cva of training data 
	 *   @param trainDataVols - indices of vols (rows) of training data in 
	 *                          full data set 
	 */  
	private Matrix getTrainCVScores(CVA cvaTrain, int[] trainDataVols) {
		Matrix cvsTr = cvaTrain.getCVScores();
		Matrix cvsTrPadded = cvsTr.zeroPadRows(setupParams.getNumVols(), trainDataVols);
		return cvsTrPadded;
	}
	

	
//	private void saveSplitVolInfo() throws IOException {
//		// Save splits vol info into single read_matrix.pro-format file
//		// (compatible with IDL npairs SETUP .vols file)
//		// NOTE that volume indices are 1-RELATIVE in IDL-compatible file
//		int numSamples = resampler.getNumSamples();
////		int numSamples = splits[0].length;
//		//reorder 'splits' so first row == first split half sample 1,
//		//                   second row == 2nd split half sample 1,
//		//                    third row == first split half sample 2,
//		//                   fourth row == 2nd split half sample 2,
//		//                              ... etc. 
//		//  store result in tmpSplits
//		// NOTE that split halves containing less than max no. of vols
//		// across all split halves will be zero-padded so all rows have same
//		// no. of elements
//		int[][] tmpSplits = new int[2 * numSamples][];
//		int maxNumVols = 0;
//		for (int s = 0; s < numSamples; ++s) {
//			int currMax = Math.max(splits[0][s].length, splits[1][s].length);
//			maxNumVols = Math.max(maxNumVols, currMax);
//		}
//		for (int s = 0; s < numSamples; ++s) {
//			
//			int[] zeropadSplits0 = new int[maxNumVols];
//			for (int i = 0; i < splits[0][s].length; ++i) {
//				zeropadSplits0[i] = splits[0][s][i] + 1;
//			}
//			for (int j = splits[0][s].length; j < maxNumVols; ++j) {
//				zeropadSplits0[j] = 0;
//			}
//			int[] zeropadSplits1 = new int[maxNumVols];
//			for (int i = 0; i < splits[1][s].length; ++i) {
//				zeropadSplits1[i] = splits[1][s][i] + 1;
//			}
//			for (int j = splits[1][s].length; j < maxNumVols; ++j) {
//				zeropadSplits1[j] = 0;
//			}
//
//			tmpSplits[2 * s] = zeropadSplits0;
//			tmpSplits[2 * s + 1] = zeropadSplits1;
//		}
//
//		String splitsInfoSaveFilename = setupParams.getResultsFilePrefix() + ".vols";
//		NpairsjIO.printToIDLFile(tmpSplits, splitsInfoSaveFilename);
//	}
	
	
	private void saveAvgSpatPattern(String format) {
		if (format.toUpperCase().equals("IDL")) {
			String avgSpatPattFilename = setupParams.getResultsFilePrefix() + ".CVA.SUMM.AVG.eigim";
			avgSpatialPattern.printToFile(avgSpatPattFilename, format);
		}
		else {
			throw new IllegalArgumentException("Input format \'" + format + "\' not "
					+ "implemented.");
		}
	}
	
	
	private void saveZScoreAvgPatt(String format) {
		if (format.toUpperCase().equals("IDL")) {
			String avgZScorePattFilename = setupParams.getResultsFilePrefix() + ".CVA.SUMM.AVG.rSPM-Z";
			avgZScorePattern.printToFile(avgZScorePattFilename, format);
		}
		else {
			throw new  IllegalArgumentException("Input format \'" + format + "\' not "
					+ "implemented.");
		}
	}
	
	
	private void saveNoiseAvgPatt(String format) {
		if (format.toUpperCase().equals("IDL")) {
			String avgNoisePattFilename = setupParams.getResultsFilePrefix() + ".CVA.SUMM.AVG.noise";
			avgNoisePattern.printToFile(avgNoisePattFilename, format);
		}
		else {
			throw new  IllegalArgumentException("Input format \'" + format + "\' not "
					+ "implemented.");
		}
	}
	
	
	private void saveNoiseStdDev(String format) {
		if (format.toUpperCase().equals("IDL")) {
			String noiseStdDevFilename = setupParams.getResultsFilePrefix() + ".CVA.SUMM.noise-sd";
			noisePattStdDev.printToFile(noiseStdDevFilename, format);
		}
		else {
			throw new  IllegalArgumentException("Input format \'" + format + "\' not "
					+ "implemented.");
		}
	}
	
	
	private void saveCorrCoeffs(String format) {
		if (format.toUpperCase().equals("IDL")) { 
			String corrCoeffsFilename = setupParams.getResultsFilePrefix() + ".CVA.SUMM.CC";
			corrCoeffs.printToFile(corrCoeffsFilename, format);
		}
		else {
			throw new  IllegalArgumentException("Input format \'" + format + "\' not "
					+ "implemented.");
		}
	}
	
	private void saveAvgCVScores(String format) {
		if (format.toUpperCase().equals("IDL")) {
			String saveCVSTrain = setupParams.getResultsFilePrefix() + ".CVA.SUMM.AVG.CV-TR";
			avgCVScoresTrain.printToFile(saveCVSTrain, format);
			String saveCVSTest = setupParams.getResultsFilePrefix() + ".CVA.SUMM.AVG.CV-TE";
			avgCVScoresTest.printToFile(saveCVSTest, format);
		}
		else {
			throw new  IllegalArgumentException("Input format \'" + format + "\' not "
					+ "implemented.");
		}
	}
	
	
	/** Save PCA results for current split half 'splitNum'.
	 *  (Split numbers are 1-relative: 1, 2) 
	 */
	private void savePCASplitResults(int splitNum, int splitHalf) throws NpairsException { 
		
		String pcaSavePref = setupParams.getResultsFilePrefix();
		if (!setupParams.pcEigimsToBigSpace()) {
			pcaSavePref += ".InitFSpace";
		}
				
		if (splitHalf == 1) {
			NpairsIO.savePCAResultsIDL(pcaSavePref, null, true,
				splitNum, splitHalf, splitDataPCA1);
		}
		else { // save split half 2 data
			NpairsIO.savePCAResultsIDL(pcaSavePref, null, true,
					splitNum, splitHalf, splitDataPCA2);		
		}
	}
	
	
	/** Returns parameter settings used in this analysis.  
	 */
	public NpairsSetupParams getSetupParams() {
		return setupParams;
	}		
	
	/** Returns correlation coefficient for each split analysis.
	 * 
	 * @return Correlation coefficients between eigenimages from each split half analysis.
               <p>Dims: <i># splits</i> rows X <i># dims in results for model to be summarized 
               (e.g., # CV dims)</i>
               <p>Only exists if training and test sets are switched, i.e., if models 
               are generated from both split halves
     *
	 */
	public Matrix getCorrCoeffs() {
		return corrCoeffs;
	}

	/** Returns r<sup>2</sup> values calculated for each split half
    * between CV scores and data input into CV (e.g., PC scores
    * representing data in PC space)
    * @return Matrix containing r<sup>2</sup> values.
    * 		<p>Dims: <i># splits</i> X <i># data dims (e.g., PC dims) 
    * 		entered into CVA split analyses</i>.
	*/
	public Matrix[] getR2() {
		return r2;
	}	
	
	/** Returns data entered into this NPAIRS analysis.
	 *  @return NpairsDataLoader object containing masked NPAIRS data before and
	 *  after feature selection (initial EVD) plus some other stuff.
	  */
	public NpairsDataLoader getDataLoader() {
		return dataLoader;
	}

	/** Returns CVA results from full data analysis.
	 * 
	 */
	public CVA getFullDataCVA() {
		return fullDataCVA;
	}

	/** Returns CVA eigenvalues averaged across analyses of all "first" split halves.
	*
	 * @return Array containing average CV eigenvalues across all first split half 
	 *  		CVA results.
	            <p>Length of array = # CV dims.
	 * @see #getAvgSplit2CVAEvals
	 */
	public double[] getAvgSplit1CVAEvals() {
		return avgSplit1CVAEvals;
	}

	/** Returns CVA eigenvalues averaged across analyses of all "second" split halves.
	*
	 * @return Array containing average CV eigenvalues across all second split half 
	 *  		CVA results.
	            <p>Length of array = # CV dims.
	 * @see #avgSplit1CVAEvals
	 */
	public double[] getAvgSplit2CVAEvals() {
		return avgSplit2CVAEvals;
	}

	/** Returns CV scores averaged across all 'training' data sets
	 * (i.e., across all models generated via split half analyses).
	 * @return Matrix containing average 'training' CV scores.
	 * 			<p>Dims = <i># input data volumes (rows)</i> X <i># CV dims</i>.
	 */
	public Matrix getAvgCVScoresTrain() {
		return avgCVScoresTrain;
	}

	/** Returns CV scores averaged across all 'test' data sets
	 * (i.e., across all split halves used to test model generated
	 * via analysis of corresponding other split half).
	 * @return Matrix containing average 'test' CV scores.
	 * 			<p>Dims = <i># input data volumes (rows)</i> X <i># CV dims</i>.
	 */
	public Matrix getAvgCVScoresTest() {
		return avgCVScoresTest;
	}

	/** Returns posterior probability of belonging to true class
	 * for each test volume (with and without priors). 
	 * 
     * @return Array of matrices containing posterior probabilities of belonging to true class, 
     * one Matrix for each split half.
     * 		<p>Length of array: <i># split halves</i> (i.e., 2 * (<i># splits</i>)
     *      <p>Order of elements in array: 1st Matrix corresponds to 1st split half in 1st split;
     *           2nd Matrix corresponds to 2nd split half in 1st split; 3rd Matrix corresponds to
     *           1st split half in 2nd split; 4th Matrix corresponds to 2nd split half in 2nd split; 
     *           etc.
     *      <p>Dims of each Matrix: 2  X  <i>max # test volumes (scans) in a split half</i> 
     *	 <p>1st row of each Matrix = post. probs. with priors
     *   <p>2nd row of each Matrix = post. probs. without priors
     *   <p> For split halves with < <i>max # test volumes</i>, matrices are zero-padded with extra 
     *       columns so all Matrices are the same size. 
     *  
     */
	public Matrix[] getPPTrueClass() {
		return ppTrueClass;
	}

	public Matrix[] getSqrdPredError() {
		return sqrdPredError;
	}

	public Matrix[] getPredClass() {
		return predClass;
	}

	public Matrix[] getCorrectPred() {
		return correctPred;
	}

	public Matrix[][] getPPAllClasses() {
		return ppAllClasses;
	}

	public Matrix getAvgSpatialPattern() {
		return avgSpatialPattern;
	}

	public Matrix getAvgZScorePattern() {
		return avgZScorePattern;
	}


	/** Returns true if r<sup>2</sup> values have been computed 
	 *  in this analysis.
	 * @see #getR2
	 */
	public boolean computeR2() {
		return computeR2;
	}

	/** Returns output PrintStream (e.g., console or log file).
	 * @return output PrintStream. Initialized in NpairsSetupParams.
	 * (Default: System.out)
	 * @see npairs.NpairsSetupParams.#initLogFile
	 * 
	 */
	public static PrintStream getOutput() {
		return output;
	}

	protected static void setOutput(PrintStream output) {
		Npairs.output = output;
	}
}
